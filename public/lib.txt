import logging
from typing import List, Optional, Type, Any, Dict
from datetime import datetime
from pydantic import BaseModel, root_validator, ValidationError
from gql import Client, gql
from graphql import GraphQLError

# ───────────── Logger Setup ─────────────
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
handler.setFormatter(formatter)
if not logger.handlers:
    logger.addHandler(handler)

# ───────────── Filter Models ─────────────
class IncidentFilter(BaseModel):
    id: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    severities: Optional[List[str]] = None
    owners: Optional[List[str]] = None
    createdAfter: Optional[datetime] = None
    createdBefore: Optional[datetime] = None
    updatedAfter: Optional[datetime] = None
    updatedBefore: Optional[datetime] = None
    search: Optional[str] = None
    tags: Optional[List[str]] = None

    @root_validator
    def check_date_order(cls, values):
        ca, cb = values.get("createdAfter"), values.get("createdBefore")
        ua, ub = values.get("updatedAfter"), values.get("updatedBefore")
        if ca and cb and ca > cb:
            raise ValueError("createdAfter must be before createdBefore")
        if ua and ub and ua > ub:
            raise ValueError("updatedAfter must be before updatedBefore")
        return values

class PlaybookRunFilter(BaseModel):
    id: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    playbookIds: Optional[List[str]] = None
    startedAfter: Optional[datetime] = None
    startedBefore: Optional[datetime] = None
    finishedAfter: Optional[datetime] = None
    finishedBefore: Optional[datetime] = None

    @root_validator
    def check_date_order(cls, values):
        sa, sb = values.get("startedAfter"), values.get("startedBefore")
        fa, fb = values.get("finishedAfter"), values.get("finishedBefore")
        if sa and sb and sa > sb:
            raise ValueError("startedAfter must be before startedBefore")
        if fa and fb and fa > fb:
            raise ValueError("finishedAfter must be before finishedBefore")
        return values

# ───────────── Response Models ─────────────
class PageInfo(BaseModel):
    hasNextPage: bool
    endCursor: Optional[str]

class Incident(BaseModel):
    id: str
    status: str
    severity: Optional[str]
    createdAt: datetime
    updatedAt: datetime

class IncidentConnection(BaseModel):
    nodes: List[Incident]
    pageInfo: PageInfo

class PlaybookRun(BaseModel):
    id: str
    name: str
    status: str
    startedAt: datetime
    finishedAt: Optional[datetime]

class PlaybookRunConnection(BaseModel):
    nodes: List[PlaybookRun]
    pageInfo: PageInfo

# ───────────── Introspection Queries ─────────────
INTROSPECT_TYPE_QUERY = gql("""
query IntrospectType($typeName: String!) {
  __type(name: $typeName) {
    name
    kind
    description
    inputFields {
      name
      description
      type {
        kind
        name
        ofType { kind name }
      }
    }
    fields {
      name
      description
      args {
        name
        type { kind name ofType { kind name } }
      }
    }
  }
}
""")

LIST_TYPES_QUERY = gql("""
query IntrospectSchema {
  __schema {
    types {
      name
      kind
    }
  }
}
""")

# ───────────── Client ─────────────
class GreyMatterClient:
    DEFAULT_INCIDENT_FIELDS = ["id", "status", "severity", "createdAt", "updatedAt"]
    DEFAULT_PLAYBOOK_FIELDS = ["id", "name", "status", "startedAt", "finishedAt"]

    GET_INCIDENTS_QUERY = gql("""
    query GetIncidents($filter: IncidentFilter, $first: Int, $after: String) {
      incidents(filter: $filter, first: $first, after: $after) {
        nodes {
          id
          status
          severity
          createdAt
          updatedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
    """)

    GET_PLAYBOOK_RUNS_QUERY = gql("""
    query GetPlaybookRuns($filter: PlaybookRunFilter, $first: Int, $after: String) {
      playbookRuns(filter: $filter, first: $first, after: $after) {
        nodes {
          id
          name
          status
          startedAt
          finishedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
    """)

    def __init__(self, client: Client):
        self.client = client
        logger.debug("Initialized GreyMatterClient with client=%s", type(client).__name__)

    # ───────────── Pagination Validation ─────────────
    def _validate_pagination(self, first: int, after: Optional[str]):
        logger.debug("Validating pagination params: first=%r, after=%r", first, after)
        if not isinstance(first, int) or first < 1:
            logger.error("Invalid `first` value: %r", first)
            raise ValueError("`first` must be a positive integer")
        if after is not None and not isinstance(after, str):
            logger.error("Invalid `after` cursor: %r", after)
            raise ValueError("`after` cursor must be a string if provided")

    # ───────────── Core Search Method ─────────────
    def _search(
        self,
        *,
        root: str,
        filter_obj: BaseModel,
        query: Any,
        connection_model: Type[BaseModel],
        first: int,
        after: Optional[str],
    ) -> BaseModel:
        logger.info("Executing _search for root=%s", root)

        try:
            self._validate_pagination(first, after)
            filter_payload = filter_obj.dict(exclude_none=True)
            logger.debug("Filter payload for %s: %s", root, filter_payload)
        except (ValueError, ValidationError):
            logger.exception("Validation error building variables for %s", root)
            raise

        variables: Dict[str, Any] = {"filter": filter_payload, "first": first, "after": after}

        try:
            logger.debug("Sending GraphQL query for %s with variables=%s", root, variables)
            raw_resp = self.client.execute(query, variable_values=variables)
        except GraphQLError:
            logger.exception("GraphQL-level error querying %s", root)
            raise
        except Exception:
            logger.exception("Transport/HTTP error querying %s", root)
            raise

        logger.debug("Raw response for %s: %s", root, raw_resp)
        data = raw_resp.get("data", {}).get(root)
        if data is None:
            logger.error("Missing `%s` key in GraphQL response data", root)
            raise RuntimeError(f"Missing `{root}` key in response")

        try:
            parsed = connection_model.parse_obj(data)
            logger.debug("Parsed %s into %s model with %d nodes",
                         root, connection_model.__name__, len(parsed.nodes))
        except ValidationError:
            logger.exception("Failed to parse %s response into model", root)
            raise

        return parsed

    # ───────────── Public API Methods ─────────────
    def get_incidents(
        self,
        filter: Optional[IncidentFilter] = None,
        first: int = 100,
        after: Optional[str] = None,
    ) -> IncidentConnection:
        logger.info("get_incidents called")
        filter = filter or IncidentFilter()
        return self._search(
            root="incidents",
            filter_obj=filter,
            query=self.GET_INCIDENTS_QUERY,
            connection_model=IncidentConnection,
            first=first,
            after=after,
        )

    def get_playbook_runs(
        self,
        filter: Optional[PlaybookRunFilter] = None,
        first: int = 100,
        after: Optional[str] = None,
    ) -> PlaybookRunConnection:
        logger.info("get_playbook_runs called")
        filter = filter or PlaybookRunFilter()
        return self._search(
            root="playbookRuns",
            filter_obj=filter,
            query=self.GET_PLAYBOOK_RUNS_QUERY,
            connection_model=PlaybookRunConnection,
            first=first,
            after=after,
        )

    # ───────────── Introspection Utilities ─────────────
    def list_all_types(self) -> List[str]:
        """Return all type names from the API schema."""
        logger.info("Running schema introspection for all types")
        raw_resp = self.client.execute(LIST_TYPES_QUERY)
        types = [t["name"] for t in raw_resp["data"]["__schema"]["types"]]
        logger.debug("Schema types: %s", types)
        return types

    def introspect_type(self, type_name: str) -> Dict[str, Any]:
        """Return detailed info for a specific GraphQL type or input object."""
        logger.info("Running introspection for type=%s", type_name)
        raw_resp = self.client.execute(INTROSPECT_TYPE_QUERY, variable_values={"typeName": type_name})
        type_info = raw_resp["data"]["__type"]
        logger.debug("Introspection result for %s: %s", type_name, type_info)
        return type_info

    def validate_filter_against_schema(self, filter_obj: BaseModel, type_name: str) -> None:
        """Check that filter fields are valid against the live API schema."""
        type_info = self.introspect_type(type_name)
        valid_fields = {f["name"] for f in type_info.get("inputFields", [])}
        user_fields = set(filter_obj.dict(exclude_none=True).keys())
        invalid = user_fields - valid_fields
        if invalid:
            logger.error("Invalid filter fields detected: %s", invalid)
            raise ValueError(f"Invalid filter fields for {type_name}: {invalid}")
        logger.info("Filter validated against %s successfully", type_name)
