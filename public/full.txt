import logging
from typing import List, Optional, Type, Any, Dict
from datetime import datetime
from pydantic import BaseModel, root_validator, ValidationError
from gql import Client, gql
from graphql import GraphQLError

# ───────────────────────────── Logger Configuration ───────────────────────────
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)  # Use INFO or WARNING in production
handler = logging.StreamHandler()
formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
handler.setFormatter(formatter)
if not logger.handlers:
    logger.addHandler(handler)

# ───────────────────────────── Filter Models ──────────────────────────────────
class IncidentFilter(BaseModel):
    id: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    severities: Optional[List[str]] = None
    owners: Optional[List[str]] = None
    createdAfter: Optional[datetime] = None
    createdBefore: Optional[datetime] = None
    updatedAfter: Optional[datetime] = None
    updatedBefore: Optional[datetime] = None
    search: Optional[str] = None
    tags: Optional[List[str]] = None

    @root_validator
    def check_date_order(cls, values):
        ca, cb = values.get("createdAfter"), values.get("createdBefore")
        ua, ub = values.get("updatedAfter"), values.get("updatedBefore")
        if ca and cb and ca > cb:
            raise ValueError("createdAfter must be before createdBefore")
        if ua and ub and ua > ub:
            raise ValueError("updatedAfter must be before updatedBefore")
        return values

class PlaybookRunFilter(BaseModel):
    id: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    playbookIds: Optional[List[str]] = None
    startedAfter: Optional[datetime] = None
    startedBefore: Optional[datetime] = None
    finishedAfter: Optional[datetime] = None
    finishedBefore: Optional[datetime] = None

    @root_validator
    def check_date_order(cls, values):
        sa, sb = values.get("startedAfter"), values.get("startedBefore")
        fa, fb = values.get("finishedAfter"), values.get("finishedBefore")
        if sa and sb and sa > sb:
            raise ValueError("startedAfter must be before startedBefore")
        if fa and fb and fa > fb:
            raise ValueError("finishedAfter must be before finishedBefore")
        return values

# ───────────────────────────── Response Models ────────────────────────────────
class PageInfo(BaseModel):
    hasNextPage: bool
    endCursor: Optional[str]

class Incident(BaseModel):
    id: str
    status: str
    severity: Optional[str]
    createdAt: datetime
    updatedAt: datetime

class IncidentConnection(BaseModel):
    nodes: List[Incident]
    pageInfo: PageInfo

class PlaybookRun(BaseModel):
    id: str
    name: str
    status: str
    startedAt: datetime
    finishedAt: Optional[datetime]

class PlaybookRunConnection(BaseModel):
    nodes: List[PlaybookRun]
    pageInfo: PageInfo

# ───────────────────────────── Introspection Queries ──────────────────────────
INTROSPECT_TYPE_QUERY = gql("""
query IntrospectType($typeName: String!) {
  __type(name: $typeName) {
    name
    fields {
      name
      description
    }
    inputFields {
      name
      description
    }
  }
}
""")

# ───────────────────────────── GreyMatter Client ──────────────────────────────
class GreyMatterClient:
    def __init__(self, client: Client):
        self.client = client
        logger.debug("Initialized GreyMatterClient with client=%s", type(client).__name__)

    # ───────────── Introspection Helper ─────────────
    def introspect_type(self, type_name: str) -> Dict[str, Any]:
        """Return schema details for a given GraphQL type."""
        raw_resp = self.client.execute(INTROSPECT_TYPE_QUERY, variable_values={"typeName": type_name})
        return raw_resp["data"]["__type"]

    # ───────────── NEW: Dynamic field validation ─────────────
    def _validate_fields_against_schema(self, type_name: str, fields: List[str]):
        """
        ✅ CHANGED: Added this method to check user-specified node_fields
        against the live schema for the given type (Incident or PlaybookRun).
        """
        type_info = self.introspect_type(type_name)
        valid_fields = {f["name"] for f in type_info.get("fields") or []}
        invalid = set(fields) - valid_fields
        if invalid:
            raise ValueError(f"Invalid fields for {type_name}: {invalid}")
        logger.debug("Validated node_fields for %s: %s", type_name, fields)

    # ───────────── Core Search Method ─────────────
    def _validate_pagination(self, first: int, after: Optional[str]):
        if not isinstance(first, int) or first < 1:
            raise ValueError("`first` must be a positive integer")
        if after is not None and not isinstance(after, str):
            raise ValueError("`after` cursor must be a string if provided")

    def _search(
        self,
        *,
        root: str,
        filter_obj: BaseModel,
        query: Any,
        connection_model: Type[BaseModel],
        first: int,
        after: Optional[str],
    ) -> BaseModel:
        self._validate_pagination(first, after)
        variables: Dict[str, Any] = {"filter": filter_obj.dict(exclude_none=True), "first": first, "after": after}
        raw_resp = self.client.execute(query, variable_values=variables)
        data = raw_resp.get("data", {}).get(root)
        if data is None:
            raise RuntimeError(f"Missing `{root}` key in response")
        return connection_model.parse_obj(data)

    # ───────────── UPDATED get_incidents ─────────────
    def get_incidents(
        self,
        filter: Optional[IncidentFilter] = None,
        node_fields: List[str] = None,
        first: int = 100,
        after: Optional[str] = None,
    ) -> IncidentConnection:
        """
        ✅ CHANGED: Now requires `node_fields` parameter.
        ✅ CHANGED: Validates requested fields against Incident type via introspection.
        ✅ CHANGED: Builds GraphQL query dynamically with node_fields.
        """
        if not node_fields or not isinstance(node_fields, list):
            raise ValueError("node_fields must be a non-empty list")

        self._validate_fields_against_schema("Incident", node_fields)
        fields_block = "\n          ".join(node_fields)

        query = gql(f"""
        query GetIncidents($filter: IncidentFilter, $first: Int, $after: String) {{
          incidents(filter: $filter, first: $first, after: $after) {{
            nodes {{
              {fields_block}
            }}
            pageInfo {{
              hasNextPage
              endCursor
            }}
          }}
        }}
        """)

        filter = filter or IncidentFilter()
        return self._search(
            root="incidents",
            filter_obj=filter,
            query=query,
            connection_model=IncidentConnection,
            first=first,
            after=after,
        )

    # ───────────── UPDATED get_playbook_runs ─────────────
    def get_playbook_runs(
        self,
        filter: Optional[PlaybookRunFilter] = None,
        node_fields: List[str] = None,
        first: int = 100,
        after: Optional[str] = None,
    ) -> PlaybookRunConnection:
        """
        ✅ CHANGED: Now requires `node_fields` parameter.
        ✅ CHANGED: Validates requested fields against PlaybookRun type via introspection.
        ✅ CHANGED: Builds GraphQL query dynamically with node_fields.
        """
        if not node_fields or not isinstance(node_fields, list):
            raise ValueError("node_fields must be a non-empty list")

        self._validate_fields_against_schema("PlaybookRun", node_fields)
        fields_block = "\n          ".join(node_fields)

        query = gql(f"""
        query GetPlaybookRuns($filter: PlaybookRunFilter, $first: Int, $after: String) {{
          playbookRuns(filter: $filter, first: $first, after: $after) {{
            nodes {{
              {fields_block}
            }}
            pageInfo {{
              hasNextPage
              endCursor
            }}
          }}
        }}
        """)

        filter = filter or PlaybookRunFilter()
        return self._search(
            root="playbookRuns",
            filter_obj=filter,
            query=query,
            connection_model=PlaybookRunConnection,
            first=first,
            after=after,
        )
