from typing import List, Optional, Type, Any
from datetime import datetime
from pydantic import BaseModel, root_validator
from gql import Client


# --- Filter Models -----------------------------------------------------------

class IncidentFilter(BaseModel):
    id: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    severities: Optional[List[str]] = None
    owners: Optional[List[str]] = None
    createdAfter: Optional[datetime] = None
    createdBefore: Optional[datetime] = None
    updatedAfter: Optional[datetime] = None
    updatedBefore: Optional[datetime] = None
    search: Optional[str] = None
    tags: Optional[List[str]] = None

    @root_validator
    def check_date_order(cls, values):
        ca, cb = values.get("createdAfter"), values.get("createdBefore")
        ua, ub = values.get("updatedAfter"), values.get("updatedBefore")
        if ca and cb and ca > cb:
            raise ValueError("createdAfter must be before createdBefore")
        if ua and ub and ua > ub:
            raise ValueError("updatedAfter must be before updatedBefore")
        return values


class PlaybookRunFilter(BaseModel):
    id: Optional[List[str]] = None
    statuses: Optional[List[str]] = None
    playbookIds: Optional[List[str]] = None
    startedAfter: Optional[datetime] = None
    startedBefore: Optional[datetime] = None
    finishedAfter: Optional[datetime] = None
    finishedBefore: Optional[datetime] = None

    @root_validator
    def check_date_order(cls, values):
        sa, sb = values.get("startedAfter"), values.get("startedBefore")
        fa, fb = values.get("finishedAfter"), values.get("finishedBefore")
        if sa and sb and sa > sb:
            raise ValueError("startedAfter must be before startedBefore")
        if fa and fb and fa > fb:
            raise ValueError("finishedAfter must be before finishedBefore")
        return values


# --- Response Models ---------------------------------------------------------

class Incident(BaseModel):
    id: str
    status: str
    severity: Optional[str]
    createdAt: datetime
    updatedAt: datetime


class PlaybookRun(BaseModel):
    id: str
    name: str
    status: str
    startedAt: datetime
    finishedAt: Optional[datetime]


class PageInfo(BaseModel):
    hasNextPage: bool
    endCursor: Optional[str]


class IncidentConnection(BaseModel):
    nodes: List[Incident]
    pageInfo: PageInfo


class PlaybookRunConnection(BaseModel):
    nodes: List[PlaybookRun]
    pageInfo: PageInfo


# --- Client ------------------------------------------------------------------

class GreyMatterClient:
    """
    Generic GraphQL client for ReliaQuest GreyMatter.
    Expects a `gql.Client` or any client with an `execute(query, variable_values)` method.
    """

    GET_INCIDENTS_QUERY = """
    query GetIncidents($filter: IncidentFilter, $first: Int, $after: String) {
      incidents(filter: $filter, first: $first, after: $after) {
        nodes {
          id
          status
          severity
          createdAt
          updatedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
    """

    GET_PLAYBOOK_RUNS_QUERY = """
    query GetPlaybookRuns($filter: PlaybookRunFilter, $first: Int, $after: String) {
      playbookRuns(filter: $filter, first: $first, after: $after) {
        nodes {
          id
          name
          status
          startedAt
          finishedAt
        }
        pageInfo {
          hasNextPage
          endCursor
        }
      }
    }
    """

    def __init__(self, client: Client):
        self.client = client

    def _validate_pagination(self, first: int, after: Optional[str]):
        if not isinstance(first, int) or first < 1:
            raise ValueError("`first` must be a positive integer")
        if after is not None and not isinstance(after, str):
            raise ValueError("`after` cursor must be a string if provided")

    def _search(
        self,
        *,
        root: str,
        filter_obj: BaseModel,
        query: str,
        connection_model: Type[BaseModel],
        first: int,
        after: Optional[str],
    ) -> BaseModel:
        # 1. Validate inputs
        self._validate_pagination(first, after)
        filter_payload = filter_obj.dict(exclude_none=True)

        # 2. Execute GraphQL request
        variables = {"filter": filter_payload, "first": first, "after": after}
        raw_resp = self.client.execute(query, variable_values=variables)

        # 3. Basic response sanity-check
        if not isinstance(raw_resp, dict) or "data" not in raw_resp:
            raise RuntimeError("Unexpected GraphQL response format: no `data` key")
        data = raw_resp["data"].get(root)
        if data is None:
            raise RuntimeError(f"Missing `{root}` field in GraphQL response")

        # 4. Validate & parse into typed model
        return connection_model.parse_obj(data)

    def get_incidents(
        self,
        filter: Optional[IncidentFilter] = None,
        first: int = 100,
        after: Optional[str] = None,
    ) -> IncidentConnection:
        """Search incidents with optional filtering and cursor-based pagination."""
        filter = filter or IncidentFilter()
        return self._search(
            root="incidents",
            filter_obj=filter,
            query=self.GET_INCIDENTS_QUERY,
            connection_model=IncidentConnection,
            first=first,
            after=after,
        )

    def get_playbook_runs(
        self,
        filter: Optional[PlaybookRunFilter] = None,
        first: int = 100,
        after: Optional[str] = None,
    ) -> PlaybookRunConnection:
        """Search playbookRuns with optional filtering and cursor-based pagination."""
        filter = filter or PlaybookRunFilter()
        return self._search(
            root="playbookRuns",
            filter_obj=filter,
            query=self.GET_PLAYBOOK_RUNS_QUERY,
            connection_model=PlaybookRunConnection,
            first=first,
            after=after,
        )
